# vim: ft=sh ts=4

if ! [[ "${FUNCNAME[1]}" = ammLibLoad* ]]; then
	echo >&2 "You must not source this library ($BASH_SOURCE): Use function ammLibLoad"
	exit 1
fi

# -----------------------------------------------------------------------------
# AMM Lib meta stubs
# -----------------------------------------------------------------------------

function ammPkgMetaInit {
	ammLibRequire string
	ammExecRequires ldd

	# Try to load the local package manager to avoid redundancy
	typeset localpkgmgr="$(ammPkgManagerDetect)"
	if [[ -n "$localpkgmgr" ]]; then
		ammLibLoad "pkg.$localpkgmgr" && __AMMPKG_PATHTOTYPE[/]="$localpkgmgr"
	fi

	return 0
}

# -----------------------------------------------------------------------------
# Sub-libraries managment
# -----------------------------------------------------------------------------

typeset -gA __AMMPKG_PATHTOTYPE

# @description Detect the package manager for a given path
#
# @arg $1 the path to search for related package manager
#
# @stdout  The package manager library name (without "pkg." prefix). ex: "yum"
function ammPkgManagerDetect {
	typeset rootpath="${1:-/}"

	# Portage: Gentoo
	if [[ -s "$rootpath/var/lib/portage/world" ]]; then
		echo "portage";

	# RPM: Redhat, Centos, Mandriva
	elif [[ -s "$rootpath/var/lib/yum/uuid" ]]; then
		echo "yum"
	elif [[ -s "$rootpath/var/lib/dnf/groups.json" ]]; then
		#echo "dnf"
		echo "yum"
	elif [[ -s "$rootpath/var/lib/rpm/Packages" ]]; then
		echo "rpm";

	# apt: Debian, Ubuntu
	elif [[ -d "$rootpath/var/lib/apt" ]]; then
		echo "apt"

	# No quick way to find, try with loading all libs
	else
		typeset -a mgr
		typeset sublib
		for sublib in $(ammLibLocatePattern "pkg.*"); do
			ammLogDbg "Found sublib '$sublib'"
			if ammLibLoadable "$sublib" >/dev/null; then
				ammLibLoad "$sublib"

				typeset libtype="${sublib#pkg.}"

				# If the package manager is ok, good
				if ammPkg${libtype^}IsAvailable "$rootpath"; then
					mgr+=("$libtype")
				fi
			fi
		done

		if [[ ${#mgr[@]} -eq 1 ]]; then
			echo $mgr
			return 0
		elif [[ ${#mgr[@]} -gt 1 ]]; then
			#$AMMLIB_INTERACTIVE &&
			ammLogWrn "Multiple package managers available: '${mgr[@]}'"
			return 1
		else
			ammLogErr "Unhandled or inexistant package manager on '$rootpath'"
			return 1
		fi
	fi

	return 0
}

# @description (private) dispatch generic pkg call to selected submodule
#
# @arg $1  (string) function name to call
# @arg $2  (path)(optionnal)
# @arg $@  (any) argument to pass to the selected function
function _ammPkgProxy {
	typeset func="$1"; shift

	typeset path="/"
	# Some functions like "Extract" need a path.
	# TODO: make it smarter, like test if the path is a valid chroot or smth like this
	if [[ -n "${1:-}" ]] && [[ -d "$1" ]] && [[ "$func" != "Extract" ]]; then
		path="$1"
		shift
	fi

	# Use the mapping if available
	if ( set +u; [[ -n ${__AMMPKG_PATHTOTYPE[$path]} ]] ); then
		lib="${__AMMPKG_PATHTOTYPE[$path]}"

	# Else, create and populate it
	else
		lib="$(ammPkgManagerDetect "$path")"
		if [[ -n "$lib" ]]; then
			__AMMPKG_PATHTOTYPE[$path]="$lib"
		fi
	fi

	# Load the target library
	if ! ammLibLoad "pkg.$lib"; then
		ammLogErr "Unable to load package manager '$lib' for path '$path'. This should be reported !"
		return 1
	fi

	# Call the target function
	ammPkg${lib^}${func} "$@"
}

# -----------------------------------------------------------------------------
# Main package manager operations
# -----------------------------------------------------------------------------

function ammPkgInstall {
	_ammPkgProxy "Install" "$@"
}

function ammPkgRemove {
	_ammPkgProxy "Remove" "$@"
}

# What files or requirements does a pkg need
function ammPkgInfoRequires {
	_ammPkgProxy "InfoRequires" "$@"
}

function ammPkgInfoWhatProvides {
	_ammPkgProxy "InfoWhatProvides" "$@"
}

# -----------------------------------------------------------------------------
# Less used package manager operations
# -----------------------------------------------------------------------------

function ammPkgFix {
	_ammPkgProxy "Fix" "$@"
}

function ammPkgExtract {
	_ammPkgProxy "Extract" "$@"
}

# -----------------------------------------------------------------------------
# Generic fetcher
# -----------------------------------------------------------------------------

# @description Private: lists all libraries needed by a file and all these libraries dependencies too
#
# @arg $@  file path to scan for librariries
#
# @stdout List of libraries path with matching file (their full path)
# @stderr List of libraries without matching file (only printin name)
function _ammPkgDepsFindBin {

	! ammExecExists ldd && return 1

	typeset file
	for file in "$@"; do

		typeset lib _arrow file address _junk
		while read lib _arrow file address _junk; do
			# Empty file: maybe vdso or ld-linux or error msg "not a dynamic executable"
			[[ -n "$file" ]] || continue
			#[[ "$lib" == "libc.so.6" ]] || continue

			if [[ -e "$file" ]]; then
					echo "$file"
			else
				echo >&2 "$lib"
			fi

			# Recursion
			[[ -e "$file" ]] && _ammPkgDepsFindBin "$file"

		done < <(ldd "$file" 2>/dev/null)
	done
}


# @description Smart extractor for a package, binary or feature and its dependencies
#
# @Ã¦rg $1 string Destination path for extraction.
# @arg $@ string List of packages, binaries or urls to extract, with their dependencies
function ammPkgExtractWithDeps {
	typeset dest="$1"; shift

	if ! [[ -d "$dest" ]]; then
		ammLogErr "Destination '$dest' does not exists. Create it beforehand"
		return 1
	fi

	typeset    pkgsToDl
	typeset -A pkgFiles
	typeset tmpdir="$__AMMLIB_DATATMP/ammPkg/extract"
	mkdir -p "$tmpdir"

	# For each provided element, we'll guess its type, action and extract it
	typeset element
	for element in "$@"; do
		typeset type="$(ammStringType "$element")"
		ammLogDbg "Processing element '$element' (type: $type)"

		#
		# URI: Download the file locally for further analysis
		#
		if [[ "$type" == "uri" ]]; then
			if ! ammLibLoad http >/dev/null; then
				ammLogErr "Cannot load required library http to process uri '$element'. Skipping"
				continue
			fi

			typeset destfile="$tmpdir/${elements##*/}"

			# Download the uri
			if ! ammHttpFetch "$element" "$destfile"; then
				ammLogErr "Unable to fetch uri '$element' as '$destfile'"
				continue
			fi

			#pkgFiles+="$destfile "

			# Override the just downloaded file
			if [[ -e "$destfile" ]]; then
				type="file"
				element="$destfile"
			fi
		fi

		#
		# file: check format
		#
		if [[ "$type" == "file" ]]; then

			# For now, assume a binary. Else, just skip (may comment following test)
			if head -n 1 "$element" | grep ELF >/dev/null 2>&1; then

				ammLogDbg "Extracting dependencies from ELF binary '$element'"

				typeset file
				for file in $(_ammPkgDepsFindBin $element 2>/dev/null | sort -u); do
					ammLogDbg "Searching package for file '$file'"

					# if file is not absolute, we are missing it. Add a refrence to /lib in the path
					if [[ "${file:0:1}" != "/" ]]; then
						file="*lib*/$file"
					fi

					# File already in cache, already found. Skip
					if ( set +u; [[ -n "${pkgFiles[$file]}" ]] ) ; then
						ammLogDbg "File $file already found its package(s): '${pkgFiles[$file]}'"
						continue

					# Finds from which package the file comes from
					else
						typeset pkg="$(ammPkgInfoWhatProvides "$file")"
						if [[ -z "$pkg" ]]; then
							ammLogWrn "Unable to find package providing file '$file'."
							continue
						fi

						# Check output for multiple packages
						[[ "${pkg// /}" != "$pkg" ]] && ammLogWrn "Multiple packages found providing file '$file': $pkg"

						pkgFiles[$file]="$pkg"
						pkgsToDl+="$pkg "
					fi
				done

			# not a binary... just find its owner and add it
			else

				# Find the owner
				typeset pkg="$(ammPkgInfoWhatProvides "$element")"
				if [[ -z "$pkg" ]]; then
					ammLogWrn "Unable to find package providing file '$element'."
					continue
				fi

				# And add it
				pkgsToDl+="$pkg "
			fi

		# Should be a package name
		else
			# Just append to packages to download
			pkgsToDl+="$element "
		fi

	done

	# With every element downloaded, extract them and their dependencies
	ammLogInf "Will extract packages: $pkgsToDl"

	typeset pkg
	for pkg in $pkgsToDl; do
		ammPkgExtract "$dest" "$pkg" || ammLogWrn "Error while extracting '$pkg' to '$dest': ret=$?"
	done
}
