# vim: ft=sh ts=4

if ! [[ "${FUNCNAME[1]}" = ammLib::Load* ]]; then
	echo >&2 "You must not source this library ($BASH_SOURCE): Use function ammLib::Load"
	exit 1
fi

# -----------------------------------------------------------------------------
# AMM Lib meta stubs
# -----------------------------------------------------------------------------

function ammStorage::MetaCheck {
	# Should be in util-linux
	ammExec::RequireOne lsblk blkid
}

function ammStorage::MetaInit {

	# MD should always be 9 (defined in major.h)
	typeset -gi AMMSTORAGE_MAJOR_MD="$(ammStorage::_GetModuleMajor "md")"
	typeset -gi AMMSTORAGE_MAJOR_DM="$(ammStorage::_GetModuleMajor "device-mapper")"


	typeset -ga AMMSTORAGE_LSBLKFIELDS=(
		# Identifiers & HW Spec
		"NAME" "KNAME" "PATH" "MAJMIN" "UUID" "VENDOR" "MODEL" "SERIAL" "SIZE"
		# Partition
		"PTUUID" "PTTYPE" "PARTTYPE" "PARTTYPENAME" "PARTLABEL" "PARTUUID" "PARTFLAGS"
		# Filesystem
		"FSTYPE" "FSAVAIL" "FSSIZE" "FSUSED" "FSUSE" "FSVER" "LABEL" "MOUNTPOINT" 
		"OWNER" "GROUP" "MODE"
		# Flags and state
		"RA" "RO" "RM" "HOTPLUG" "STATE"
		"ALIGNMENT" "MINIO" "OPTIO" "PHYSEC" "LOGSEC" "ROTA"
		# Queue size
		"SCHED" "RQSIZE" "DISCALN" "DISCGRAN" "DISCMAX" "DISCZERO"
		"TYPE" "RAND" "PKNAME" "WSAME" "WWN" "HCTL" "TRAN" "SUBSYSTEMS" "REV" "ZONED"
	)
	# Will create associative arrays from the fields list
	eval "typeset -gA AMMSTORAGE_BLK2{$(export IFS=,; echo "${AMMSTORAGE_LSBLKFIELDS[*]}")}"

}

# -----------------------------------------------------------------------------
# Internal helpers
# -----------------------------------------------------------------------------

function ammStorage::_GetFromSysfs {
	typeset blockdev="$1"
	typeset part="$2"

	if [[ -r "/sys/class/block/$blockdev/$part" ]]; then
		echo $(</sys/class/block/$blockdev/$part)
		return 0
	else
		ammLog::Dbg "Invalid requested sysfs '$blockdev' / '$part'"
		return 1
	fi
}

function ammStorage::_GetModuleMajor {
	typeset modname="$1"

	typeset maj mod _junk zoneblock=false
	while read maj mod _junk; do
		if $zoneblock; then
			[[ "$mod" == "$modname" ]] && echo $maj
		else
			[[ "$maj $mod" == "Block devices:" ]] && zoneblock=true
		fi
	done < /proc/devices
}


function ammStorage::_CacheBlkData {

	if ammExec::Exists "lsblk"; then
		typeset line
		while read line; do
			line="${line//%/}"
			typeset name="${line%% *}"
			name="${name#*=}"
			ammLog::Dbg "Parsing lsblk '$name': '$line'"

			# Use regex to parse all pairs
			while [[ "$line" =~ \ *([^=]+)=\"([^\"]*)\" ]]; do
				line="${line% }"
				typeset var="${BASH_REMATCH[1]}"  val="${BASH_REMATCH[2]}" tuple="${BASH_REMATCH[0]}"

				# Rename the var + fix locality to current function
				var="${var//[-:%]/}"

				eval "AMMSTORAGE_BLK2${var}[$name]='$val'"
				line="${line:${#tuple}}"
			done

		done < <(lsblk --pairs --output-all --bytes)

	else

		ammLog::Err "lsblk replacement is not yet done. Please install it !"
		return 1
	fi
}


# -----------------------------------------------------------------------------
# Listing devices and discovery
# -----------------------------------------------------------------------------

function ammStorage::GetRealName {
	ammLog::Deprecated "ammStorage::GetKernelName"
}


# @description  Returns the kernel (real) name of the device name or path
# @arg $1  (string) Name or path to the device
function ammStorage::GetKernelName {
	typeset name="$1"

	typeset realpath=""

	# Shortname
	if [[ "${name:0:1}" != "/" ]]; then
		# Simple case: already real name with dev (maj:min) file
		if [[ -e "/sys/class/block/$name/dev" ]]; then
			ammLog::Dbg "Device '$name' exists in /sys/class/block"
			echo "$name"
			return 0

		# Not real name, try with usual path
		else
			if [[ -e "/dev/$name" ]]; then
				realpath="$(readlink -f "/dev/$name")"
				ammLog::Dbg "Device name '$name' (in /dev) maps to '$realpath'"
			elif [[ -e "/dev/mapper/$name" ]]; then
				realpath="$(readlink -f "/dev/mapper/$name")"
				ammLog::Dbg "Device name '$name' (in /dev/mapper) maps to '$realpath'"
			fi
		fi
	# Starts with / treat as absolute path
	else
		# Need real block device (dm-X instead of lvm "vgname-lvname" symlink)
		realpath="$(readlink -f $name)"

		ammLog::Dbg "Device path '$name' maps to '$realpath'"

		if [[ -e "/sys/class/block/${realpath##*/}/dev" ]]; then
			echo "${realpath##*/}"
			return 0
		fi
	fi

	# Blockdevice exists (but can be an mknod' alias name
	if [[ -b "$realpath" ]]; then

		# If there is an entry in /sys for this disk/virt/part... got real
		typeset devname="${realpath##*/}"
		if [[ -d "/sys/class/block/$devname" ]]; then
			echo "$devname"
			return 0

		# Not real name (eg mknod toto). Resolution through MAJ:MIN
		else
			typeset maj min btest
			read maj min < <(ammStorage::GetMajorMinor "$realpath")

			# There should be only 1 *direct* listing with this maj/min
			for btest in /sys/class/block/*/dev; do
				if [[ "$(<$btest)" == "$maj:$min" ]]; then
					btest="${btest%/dev}"
					echo "${btest##*/}"
					return 0
				fi
			done
		fi
	fi

	ammLog::Err "Unable to get real name for device '$name'"
	return 1
}

# @description  Returns the "Major Minor" format of the given device
# @arg $1  (string) Name of path of the block device
function ammStorage::GetMajorMinor {
	typeset blockdev="$1"

	# Cannot call GetKernelName before, can create infinite loop
	if ! ammStorage::Exists "$blockdev"; then
		ammLog::Err "Invalid blockdev '$blockdev'. Cannot get Major/minor"
		return 1
	fi

	typeset blockname="$(ammStorage::GetKernelName "$blockdev")"

	typeset majmin=$(</sys/class/block/$blockname/dev)
	echo "${majmin%%:*} ${majmin##*:}"
}


function ammStorage::GetType {
	typeset dev="$(ammStorage::GetKernelName "$1")"
	[[ -z "$dev" ]] && return 1

# TODO: return a type: "nvme" "hdd" "ssd" "mdraid" "multipath" "luks1" "luks2" ..
# TODO: plus a subtype: crypt (luks aes-xts-plain64), part (nvme), lvm (meta), lvm (thin)
	typeset -l typ=""
	typeset tmp=
	# partition
	if ammStorage::IsPartition "$dev"; then
		typ="part"
	# DeviceMapper (LVM CRYPT-LUKS2 )
	elif tmp=$(ammStorage::_GetFromSysfs "$dev" "dm/uuid"); then
		
		typ="${tmp%%-*}"
	# NVMe
	elif [[ "${dev#nvme}" != "$dev" ]]; then
		typ="nvme"
	# Scsi Disk (sd)
	elif [[ "${dev#sd[a-z]}" != "$dev" ]]; then
		typ="disk"
	fi

	if [[ -z "$typ" ]]; then
		ammLog::Dbg "Unable to get the type of '$dev'"
		return 1
	fi

	echo "$typ"
}

function ammStorage::GetName {
	typeset dev="$(ammStorage::GetKernelName "$1")"
	[[ -z "$dev" ]] && return 1

	typeset name="$(ammStorage::_GetFromSysfs "$dev" "dm/name")"
	[[ -z "$name" ]] && name="$dev"

	echo "$name"
}

function ammStorage::GetSize {
	typeset dev="$(ammStorage::GetKernelName "$1")"
	[[ -z "$dev" ]] && return 1

	typeset -i nblocks blocksize
	# each blockdev has a size
	nblocks="$(ammStorage::_GetFromSysfs "$dev" "size")"

	# But only the parent block has physical size
	blocksize="$(ammStorage::GetBlockSize "$dev")"

	echo $(($nblocks * $blocksize))
}

function ammStorage::GetBlockSize {
	typeset dev="$(ammStorage::GetKernelName "$1")"
	[[ -z "$dev" ]] && return 1

	typeset bsize="$(ammStorage::_GetFromSysfs "$dev" "queue/physical_block_size")"
	if [[ -z "$bsize" ]]; then
		typeset bsizetmp=
		typeset parent
		for parent in $(ammStorage::ListParents "$dev"); do
			bsizetmp="$($FUNCNAME "$parent")"
			if [[ -n "$bsizetmp" ]] && [[ -n "$bsize" ]] && [[ "$bsizetmp" != "$bsize" ]]; then
				ammLog::Wrn "Multiple parent devices reported different block-size"
				break
			fi

			bsize="$bsizetmp"
		done
	fi

	echo $bsize
}

function ammStorage::GetModel {
	typeset dev="$(ammStorage::GetKernelName "$1")"
	[[ -z "$dev" ]] && return 1

	typeset model="$(ammStorage::_GetFromSysfs "$dev" "device/model")"
	# No direct model, fallback depending on type
	if [[ -z "$model" ]]; then
		typeset typ="$(ammStorage::GetType "$dev")"
		case "$typ" in
			# Crypt: display type and encryption
			crypt)
				;;
			# LVM: display LVM type
			lvm)
				;;
			# partition: get from its parent
			part)
				typeset parent="$(ammStorage::ListParents "$dev")"
				[[ -z "$parent" ]] && return 1
				model="($(ammStorage::_GetFromSysfs "$parent" "device/model"))"
				;;
			*)
				return 1
		esac
	fi

	echo "$model"
}

function ammStorage::GetSerial {
	typeset dev="$(ammStorage::GetKernelName "$1")"
	[[ -z "$dev" ]] && return 1

	ammStorage::_GetFromSysfs "$dev" "device/serial"
}

function ammStorage::GetFirmware {
	typeset dev="$(ammStorage::GetKernelName "$1")"
	[[ -z "$dev" ]] && return 1

	ammStorage::_GetFromSysfs "$dev" "device/firmware_rev"
}

function ammStorage::GetMountpoint {
	typeset dev="$(ammStorage::GetKernelName "$1")"
	[[ -z "$dev" ]] && return 1

	typeset bdev mntpnt fstyp mntopts _junk
	while read bdev mntpnt fstyp mntopts _junk; do
		# Skip non block-backed mounts
		ammStorage::Exists $bdev || continue

		bdev="$(ammStorage::GetKernelName "$bdev")"
		if [[ "$bdev" == "$dev" ]]; then
			echo "$mntpnt"
			return 0
		fi
	done < /proc/mounts
	return 1
}

function ammStorage::Exists {
	typeset blockdev="$1"

	# absolute path
	if [[ "${blockdev:0:1}" == "/" ]]; then
		[[ -b "$blockdev" ]] && return 0

	# Short name, try in usual folders
	else
		# Direct blockdev in /dev
		[[ -b "/dev/$blockdev" ]] && return 0

		[[ -b "/dev/mapper/$blockdev" ]] && return 0

		# Folder in /sys
		[[ -d "/sys/class/block/$blockdev" ]] && return 0
	fi
	# No standard path found, invalid blockdev
	ammLog::Dbg "Invalid blockdev '$blockdev'"
	return 1
}

function ammStorage::ListChildren {
	typeset blockdev="$1"

}

function ammStorage::ListParents {
	typeset blockdev="$1"

	typeset blockname="$(ammStorage::GetKernelName "$blockdev")"
	[[ -z "$blockname" ]] && return 1

	typeset parents=""
	typeset maj min
	read maj min < <(ammStorage::GetMajMin "$blockdev")


	# For partitions, use the special name of the device
	if ammStorage::IsPartition "$blockname"; then
		typeset part="$(ammStorage::_GetFromSysfs "$blockname" "partition")"
		case $blockname in
			# SCSI disks: simple number appended
			sd*)    parents="${blockname%[0-9]}" ;;
			# NVMe or MMC: remove p* in nvme0n1p3 or mmcblk1p3
			nvme*|mmc*)  parents="${blockname%p$part}" ;;
			# Unknown scheme: use plain listing
			*)
				ammLog::Dbg "Unhandled partition naming '$blockname'. Doing listing"
				typeset bpath=""
				for bpath in /sys/class/block/*/$blockname; do
					if [[ -d "$bpath" ]]; then
						parents="${bpath#/sys/class/block/}"
						parents="${parents%/*}"
					fi
				done
				;;
		esac

	# Device Mapper
	elif [[ "$maj" == "$AMMSTORAGE_MAJOR_DM" ]]; then
		
		lsblk --pairs --output-all --bytes

	# MD-Raid device
	elif [[ "$maj" == "$AMMSTORAGE_MAJOR_MD" ]]; then
		:

	# ZFS: TODO: Parse "zpool list -vHPp"
	elif [[ -d "/sys/module/zfs" ]] && ammExec::Exists zpool && zpool list "$blockdev" >/dev/null 2>&1; then

		typeset dev _junk
		while read dev _junk; do
			:
		done < <(zpool list -vHPp "$blockdev")

	# btrfs: TODO
	elif [[ -d "/sys/module/btrfs" ]]; then
		:

	# Unknown device type...
	else
		ammLog::Err "Unable to manage '$blockname': unknown device type"
	fi


	# Check for slaves registerd in /sys
	typeset slave
	for slave in "/sys/class/block/$blockname/slaves/"*; do
		[[ -d "$slave" ]] || continue
		echo ${slave##*/}
	done
}

# @description  Try to find the real underlying device of a given blockdev
function ammStorage::ListUnderlyingDevices {
	typeset blockdev="$1"

	# Get its parents recursively
	typeset parent
	while read parent; do
# TODO !!
		:
	done < <(ammStorage::ListParents "$blockdev")
}



function ammStorage::ListAvail {
	
	typeset bdpath
	for bdpath in /sys/class/block/*; do
		echo "${bdpath##*/}"
	done
}

# -----------------------------------------------------------------------------
# Devices state check
# -----------------------------------------------------------------------------

function ammStorage::IsPartition {
	typeset blockdev="$1"

	ammStorage::_GetFromSysfs "$blockdev" "partition" >/dev/null
}

function ammStorage::IsHealthy {
	typeset blockdev="$1"
}

function ammStorage::IsComposite {
	:
}
function ammStorage::IsFlashDrive {
	typeset blockdev="$1"

	if ! ammStorage::Exists "$blockdev"; then
		ammLog::Err "Invalid block device '$blockdev'"
		return 1
	fi

	typeset blockname="$(ammStorage::GetKernelName)"
	typeset -i rotational=0

	# Get all underlying real block devices for the current one
	[[ "$(</sys/block/$blockname/queue/rotational)" == "0" ]]
}

# -----------------------------------------------------------------------------
# Device Mapper
# -----------------------------------------------------------------------------
function ammStorage::DeviceMapperGet {
	typeset dev="$1"


	ammExec::Require "dmsetup"

	typeset line
	while read line; do
		typeset name="${line%%,*}";  line="${line%%,*}"
		typeset uuid="${line%%,*}";  line="${line%%,*}"
		typeset minor="${line%%,*}"; line="${line%%,*}"
		typeset right="${line%%,*}"; line="${line%%,*}"
		typeset todo1="${line%%,*}"; line="${line%%,*}"
		typeset size="${line%%,*}";  line="${line%%,*}"
		typeset btype="${line%%,*}"; line="${line%%,*}"

		case $btype in
			# LVM
			linear)
				;;
			# Crypto
			crypt)
				;;

			*)
				;;
		esac


	done < <(ammExec::AsUser "root" "dmsetup table --concise")
}


# -----------------------------------------------------------------------------
# Destructive operations
# -----------------------------------------------------------------------------

function ammStorage::SecureErase {
	typeset elem="$1"
	typeset doit="${2:-false}"

	typeset targetdev=""
	# Only work on real mountpoint to avoid dramatic issues
	if [[ -d "$elem" ]]; then
		typeset targetdev="$(ammFs::StoreFromMountpoint "$elem")"
	# Direct device provided
	elif [[ -b "$elem" ]]; then
		targetdev="$elem"
	fi

	if [[ -z "$targetdev" ]]; then
		ammLog::Err "The element to erase '$elem' is not a device, nor a mountpoint. Skipping"
		return 1
	fi

	ammLog::Dbg "Gathering sub-devices of '$targetdev' to erase"

	# Work on all sub-devices
	typeset dev
	typeset -i r=0
	for dev in $(ammStorage::ListParents "$blockdev"); do
		typeset typ="$(ammStorage::GetType "$dev")"
		case $typ in
			# Persistent Memory
			pmem)

				;;
			# NVMe must use secure-erase
			nvme)
				if ! ammExec::Exists "nvme"; then
					ammLog::Inf "No 'nvme' tool available. Will try to install it"

					# Try to install the package
					ammLib::Require "pkg"
					if ! ammPkg::Install "nvme"; then
						ammLog::Err "Cannot get a working 'nvme' tool (usually from nvme-cli). Cannot secure-erase '$dev'"
						r+=1
						continue
					fi
				fi

				if ammString::IsYes "$doit"; then
					# https://github.com/linux-nvme/nvme-cli/blob/master/Documentation/nvme-format.txt
					\nvme format -s1 "$dev"
				else
					echo "Will erase '$dev' with 'nvme format -s1 $dev'"
				fi

				;;
			# SSD must use ATA TRIM
			ssd)

				# hdparm --trim-sector-ranges
				;;

			# HDD need to shred
			hdd)
				# Shred
				;;
		esac
	done

	return r
}

