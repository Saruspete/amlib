# vim: ft=sh ts=4

if ! [[ "${FUNCNAME[1]}" = ammLibLoad* ]]; then
	echo >&2 "You must not source this library ($BASH_SOURCE): Use function ammLibLoad"
	exit 1
fi

# -----------------------------------------------------------------------------
# Meta init
# -----------------------------------------------------------------------------

#typeset -g AMMPKGYUM_AVAIL_

# Some tools are required for this module to work
function ammPkgYumMetaInit {
	ammLibRequire pkg.rpm string
	ammExecRequires cksum gzip awk

	#ammExecRequires "repoquery"
}

function ammPkgYumIsAvailable {
	typeset rootpath="${1:-}"

	[[ -x "$rootpath/usr/bin/yum" ]]
}

# -----------------------------------------------------------------------------
# Standard operations
# -----------------------------------------------------------------------------

function _ammPkgYum {
	typeset act="$1"; shift

	typeset opts=""
	$__AMMLIB_INTERACTIVE || opts+="-y"

	# Check if input contains options
	while [[ -n "${1:-}" ]]; do
		if ammStringIsOption "$1"; then
			opts+=" $1"
			shift
		else
			break
		fi
	done

	yum $act $opts "$@"
}

function _ammPkgYumRepoquery {
	typeset act="$1"; shift
	ammExecRequest "repoquery" || return 1

	typeset opts=""

	# Check if input contains options
	while [[ -n "${1:-}" ]]; do
		if ammStringIsOption "$1"; then
			opts+=" $1"
			shift
		else
			break
		fi
	done

	repoquery $act $opts "$@"
}

function ammPkgYumInstall {
	# TODO: Make more checks for "upgrade" or "downgrade" if version provided
	_ammPkgYum "install" "$@"
}

function ammPkgYumRemove {
	_ammPkgYum "remove" "$@"
}

function ammPkgYumSearch {
	_ammPkgYum "info" "$@"
}


function ammPkgYumInfoRequiredBy {
	_ammPkgYum "deplist" "$@" | awk '
		$1 == "package:" { printf "\n"$2; }
		$1 == "provider:" { printf " $2"; }
	'
}

function ammPkgYumInfoWhatProvides {

	# Check for all input
	for element in "$@"; do
		# If it's a file already installed, use rpm (faster)
		if [[ -e "$element" ]]; then
			ammPkgRpmWhatProvides "$element"

		# Else, query all repordata
		else
			_ammPkgYum "provides" "$element"
		fi
	done
}

function ammPkgYumInfoContents {
	# Check for all input
	for pkg in "$@"; do
		# For each pkg, list content
		_ammPkgYumRepoquery "--provides" "$pkg"
	done
}

# What versions are available for a package
function ammPkgYumInfoVersions {
	typeset pkg="$1"
	yum info $pkg
}


# -----------------------------------------------------------------------------
# Data extraction
# -----------------------------------------------------------------------------

function ammPkgYumDownload {
	typeset outdir="$1"; shift

	if ammExecExists yumdownloader >/dev/null; then
		yumdownloader --destdir "$outdir" "$@"
/
	else
		yum --downloadonly --downloaddir="$outdir"
	fi
}

function ammPkgYumExtract {

	for pkg in "$@"; do
		# if the file does not exists, try to find it
		if ! [[ -e "$pkg" ]]; then

		# The file does exists, but is it a rpm ?
		elif !

		fi
	done

	ammPkgRpmExtract "$@"
}

function ammPkgYumExtractRecursive {
	:
}

# -----------------------------------------------------------------------------
# Yum emulation
# -----------------------------------------------------------------------------

function _ammPkgYumRepodataCache {
	typeset cks="$(echo "$1"|cksum)"; cks="${cks// /_}"
	typeset t="$__AMMLIB_DATATMP/pkgyum.repodata.$cks"

	mkdir -p "$t"
	echo "$t"
}

# Basic yum emulation
function ammPkgYumRepodataGet {
	typeset url="$1"

	# We need http tools for this
	if ! ammLibLoad http ; then
		ammLogErr "Unable to load http library."
		return 99
	fi

	# Download the file listing
	typeset cache="$(_ammPkgYumRepodataCache "$url")"
	typeset repomd="$cache/repomd.xml"
	ammHttpFetch "$url/repodata/repomd.xml" "$repomd"

	# Download each xml file
	typeset xmls="$(grep 'location href=' "$repomd"|grep -o '".*\.xml.gz"' | tr -d '"')"
	for xml in $xmls; do
		typeset dstfile="$cache/${xml##*/}"

		# Skip if cache already here
		[[ -s "$dstfile" ]] && continue

		ammHttpFetch "$url/$xml" "$dstfile"

		# Check and unzip
		[[ -e "$dstfile" ]] && gzip -kdf "$dstfile"
	done

	# echo output
	echo "$cache"
}

function _ammPkgYumRepodataParseFilelist {
	typeset repodata="$1"; shift

	# Parse all search
	for dep in "$@"; do

		# This is utterly ugly, and a really bad idea (parsing xml in awk...)
		# but it's the easiest available for quick an portable solution

		awk -v search="$dep" '
		# Check what are we looking for (file, package...)
		BEGIN {
			searchFile = searchName = 0
			# File search always contains /
			if (index(search, "/"))
				searchFile = 1
			else
				searchName = 1
		}

		$1 =="<package" || $1 == "<version" {
			# Check for format in multiline xml...
			if (! $NF ~ />$/) {
				# WARNING !
			}
			# remove last > (or />)
			gsub(/\/?>$/,"",$NF)

			# Package opening is for a new package. Reset old vals
			if ($1 == "<package")
				pkgname = pkgvers = pkgrel = pkgarch = ""

			for (i=2; i<=NF; i++) {
				split($i,a,"=")
				lkey = a[1]
				lval = a[2]

				# remove extra "
				gsub(/"/,"",lval)

				# Name marks a new package
				if (lkey == "name") pkgname = lval
				if (lkey == "arch") pkgarch = lval
				if (lkey == "ver")  pkgvers = lval
				if (lkey == "rel")  pkgrel  = lval
			}

			# Search against pkg name. Now we have version and can print
			if (searchName && $1 == "<version" && pkgname == search) {
				print pkgname"-"pkgvers"-"pkgrel"."pkgarch".rpm"
			}
		}
		# Search against file provided.
		searchFile && match($1, /<file>(.+)<\/file>/, b) {
			# maybe try to change the glob to regex in "search" input
			if (b[1] ~ search) {
				print pkgname"-"pkgvers"-"pkgrel"."pkgarch".rpm"
			}
		}
		' $repodata/*-filelists.xml
	done
}

# Emulate the "yum provides" feature
function ammPkgYumRepodataWhatProvides {
	typeset url="$1"; shift
	typeset pkgs=""

	typeset repodata="$(ammPkgYumRepodataGet "$url")"

	_ammPkgYumRepodataParseFilelist "$repodata" "$@" | sort | uniq
}
