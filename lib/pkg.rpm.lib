# vim: ft=sh ts=4

if ! [[ "${FUNCNAME[1]}" = ammLibLoad* ]]; then
	echo >&2 "You must not source this library ($BASH_SOURCE): Use function ammLibLoad"
	exit 1
fi

# -----------------------------------------------------------------------------
# AMM Lib meta stubs
# -----------------------------------------------------------------------------

# Some tools are required for this module to work
function ammPkgRpmMetaInit {
	ammExecRequires rpm rpm2cpio cpio
}

# -----------------------------------------------------------------------------
# Extract data
# -----------------------------------------------------------------------------

function ammPkgRpmExtract {
	typeset    dst="$1"; shift
	typeset -i ret=0

	for file in "$@"; do
		ammLogDbg "Extracting package '$file' into '$dst'"
		# Exec in subshell to avoid changing script cwd
		(
			cd "$dst"
			rpm2cpio "$file" | cpio -idm 2>/dev/null
		)
		ret+=$?
	done
	return $ret
}

# -----------------------------------------------------------------------------
# Queries
# -----------------------------------------------------------------------------

function _ammPkgRpm {

	typeset opts=""
	while [[ -n "${1:-}" ]]; do
		if ammStringIsOption "$1"; then
			opts+=" $1"
			shift

		# Maybe a special case
		else

			# If the arg is a folder, and it has a valid rpmlib db, use it
			if [[ -d "$1" ]] && [[ -s "$1/var/lib/rpm/Packages" ]]; then
				opts+=" --root='$1'"
				shift
			else
				break
			fi
		fi
	done

	# Exec the query + opts
	ammLogDbg "Executing rpm with args: $opts $@"
	rpm $opts "$@"
}

# What does a package requires
function ammPkgRpmInfoRequires {
	for file in "$@"; do
		_ammPkgRpm --query  --queryformat="%{name}.%{arch}" --requires "$file"
	done
}

# What does a package provides
function ammPkgRpmInfoProvides {
	_ammPkgRpm --query --queryformat="%{name}.%{arch}" --fileprovide "$@"
}

# What package provides a given element
function ammPkgRpmInfoWhatProvides {

	typeset element
	for element in "$@"; do
		_ammPkgRpm --query  --queryformat="%{name}.%{arch}" --file "$element"
	done
}

# 
function ammPkgRpmInfoRequiresToPkg {
	[[ -z "${1:-}" ]] && return 0

	typeset rpmopts=""

	# If the first arg is a folder, and it has a valid rpmlib db, use it
	if [[ -d "$1" ]] && [[ -s "$1/var/lib/rpm/Packages" ]]; then
		rpmopts+=" --root='$1'"
	fi

	# Process all packages
	for pkg in "$@"; do
		ammPkgInfoRequires $pkg
	done

}

# -----------------------------------------------------------------------------
# RPM DB Helper
# -----------------------------------------------------------------------------
function ammPkgRpmDbInit {
	typeset prefix="${1:-}"

	mkdir -p "$root"
	rpm --root="$root" --initdb
}

function ammPkgRpmDbKeyImport {
	typeset prefix="${1:-}"; shift;

	typeset rpmopts=""
	for key in "$@"; do
		[[ -n "$prefix" ]] && rpmopts+=" --root=$prefix"
		rpm $rpmopts "$key"
	done
}

function ammPkgRpmDbExport {
	typeset prefix="${1:-}"
	typeset exportdir="$2"

	for dbfile in $prefix/var/lib/rpm/*; do
		# Skip non BDB files
		[[ "$(file "$dbfile"|awk '{print $2,$3}')" == "BerkeleyDB" ]] || continue

		# Dump the file to target
		ammLogInf "Dumping '$dbfile' to '$exportdir'"
		/usr/lib/rpm/rpmdb_dump "$dbfile" > "$exportdir/${dbfile##*/}.dmp"
	done
}

function ammPkgRpmDbImport {
	typeset rpmdb="$1"
	typeset import="$2"

	
}

function ammPkgRpmDbRecover {
	typeset prefix="${1:-}"

	# First, try a simple recover
	/usr/lib/rpm/rpmdb_recover
	#rm $prefix/log.0000000001

}

function ammPkgRpmDbMigrate {
	typeset prefix="${1:-}"

	# 
}

# -----------------------------------------------------------------------------
# Static values, helpers...
# -----------------------------------------------------------------------------

