# vim: ft=sh ts=4

if ! [[ "${FUNCNAME[1]}" = ammLib::Load* ]]; then
	echo >&2 "You must not source this library ($BASH_SOURCE): Use function ammLib::Load"
	exit 1
fi

# -----------------------------------------------------------------------------
# AMM Lib meta stubs
# -----------------------------------------------------------------------------

function ammInput::MetaCheck {
	ammLib::Require string
}
function ammInput::MetaInit {
	ammLib::Require string
}

# Prefix to look for
typeset -g  __AMMINPUT_PREFIX="input."
# List of registered questions from InputRegister
typeset -ga __AMMINPUT_ORDER=()
typeset -gA __AMMINPUT_IDS=()
typeset -gA __AMMINPUT_DEFAULTS=()
typeset -gA __AMMINPUT_VALIDATIONCB=()
typeset -gA __AMMINPUT_HELP=()

# State for blueprint
typeset -gA __AMMINPUT_REPLIES=()
typeset -gA __AMMINPUT_REPLIES_USED=()
typeset -gA __AMMINPUT_REPLIES_UNKNOWNID=()

typeset -g __AMMINPUT_BATCH_AUTOTRY=false
typeset -g __AMMINPUT_BATCH_DIE_ON_ERR=false
typeset -g __AMMINPUT_BATCH_SILENTOK=false



# -----------------------------------------------------------------------------
# Registration
# -----------------------------------------------------------------------------
function ammInput::Register {
	typeset id="$1"
	typeset helptext="${2:-}"
	typeset default="${3:-}"
	typeset validcb="${4:-}"

	#typeset caller="${BASH_SOURCE[1]}:${FUNCNAME[1]}"

	# Fill registration values
	#__AMMINPUT_IDS[$id]="$caller"
	__AMMINPUT_ORDER[${#__AMMINPUT_ORDER[@]}]="$id"
	__AMMINPUT_IDS[$id]=""
	__AMMINPUT_DEFAULTS[$id]="$default"
	__AMMINPUT_HELP[$id]="$helptext"

	# Only call if internal function
	if [[ -n "$validcb" ]] && ammEnv::IsFunc "$validcb"; then
		__AMMINPUT_VALIDATIONCB[$id]="$validcb"
	fi
}

function ammInput::Batch {

	typeset arg
	typeset resetDone=false

	for arg in "$@"; do
		typeset fchar="${arg:0:1}"
		typeset var="$arg"
		typeset val=true

		# - feature: set feature to false
		if [[ "$fchar" == "-" ]]; then
			val=false
			var="${var:1}"
		# + feature: set feature to true
		elif [[ "$fchar" == "+" ]]; then
			var="${var:1}"
		# No prefix: reset all values and set only provided features
		else
			if ! $resetDone; then
				__AMMINPUT_BATCH_AUTOTRY=false
				__AMMINPUT_BATCH_DIE_ON_ERR=false
				__AMMINPUT_BATCH_SILENTOK=false
				resetDone=true
			fi
		fi

		# Check if the feature exists
		ammEnv::IsVar "__ammInputBatch${var}" && {
			eval "__ammInputBatch${var}=$val"
		}
	done

	# If we can't have user interaction, dont mind to ask for it
	if ! $__AMMLIB_INTERACTIVE; then
		__AMMINPUT_BATCH_AUTOTRY=true
		__AMMINPUT_BATCH_DIE_ON_ERR=true
	fi
}


function ammInput::Get {
	typeset id="$1"
	typeset prompt="${2:-}"
	typeset default="${3:-}"
	typeset readopts="${4:-}"
	typeset validcb="${5:-}"

	typeset reply=""
	typeset caller="${BASH_SOURCE[1]}:${FUNCNAME[1]}"

	# No prompt, check if one was registered beforehand
	if [[ -z "$prompt" ]]; then
		if [[ -n "$id" ]] && (set +u; [[ -n "${__AMMINPUT_HELP[$id]}" ]] ); then
			prompt="${__AMMINPUT_HELP[$id]}"
		else
			prompt="Value for '$id'"
		fi
	fi

	# Prettify the prompt
	prompt="$(ammLog::Color bold underline)${prompt}$(ammLog::Color "reset"): "

	if [[ -z "$default" ]] && [[ -n "$id" ]] && ( set +u; [[ -n "${__AMMINPUT_DEFAULTS[$id]}" ]] ); then
		default="${__AMMINPUT_DEFAULTS[$id]}"
	fi

	typeset -i ntries=0

	# Loop until input is valid for caller
	while :; do

		# set/reset the reply value
		typeset reply=""

		#
		# Set the default value
		#

		# Check if the input was already provided in options
		if [[ -n "$id" ]] && ( set +u; [[ -n "${__AMMINPUT_REPLIES[$id]:-}" ]] ); then
			# Set the reply and consume it
			default="${__AMMINPUT_REPLIES[$id]}"
			unset __AMMINPUT_REPLIES[$id]

			ammLog::Dbg "Getting reply from filled list __AMMINPUT_REPLIES[$id] => '$reply'"
		fi


		#
		# Get the reply value
		#

		# Batch mode
		if $__AMMINPUT_BATCH_AUTOTRY && [[ $ntries -eq 0 ]]; then
			reply="$default"

			# If we are not in silent mode, display the prompt nonetheless
			if ! $__AMMINPUT_BATCH_SILENTOK; then
				ammLog::WriteTerm "${prompt}${reply}"
			fi
		# Read from user input
		else
			if [[ -n "$default" ]]; then
				read -e $readopts -p "$prompt" -i "$default" reply
			else
				read -e $readopts -p "$prompt" reply
			fi
			ammLog::Dbg "Got input from user question. Id:$id Caller:$caller"
		fi

		#
		# Validation of value
		#

		# Validation (locally supplied)
		if [[ -n "$validcb" ]]; then
			# I expect it to be a simple function, not a binary
			if ammEnv::IsFunc "$validcb"; then
				if ! $validcb "$reply"; then
					ammLog::Wrn "Reply '$reply' is invalid (callback '$validcb')"

					# If we are in silent ok, and had error, display it now
					$__AMMINPUT_BATCH_SILENTOK && ammLog::WriteTerm "${prompt}${reply}"

					if $__AMMINPUT_BATCH_DIE_ON_ERR; then
						ammLog::Die "Dying due to DieOnErr requested"
					fi
				else
					ammLog::Dbg "Input validated by arg provided callback '$validcb'"
					break
				fi
			else
				ammLog::Err "Validation callback '$validcb' is not a function. Please retry"
				unset validcb
			fi

		# Validation (registration)
		elif [[ -n "$id" ]] && ( set +u; [[ -n "${__AMMINPUT_VALIDATIONCB[$id]}" ]] ); then
			typeset func="${__AMMINPUT_VALIDATIONCB[$id]}"
			if ammEnv::IsFunc "$func"; then
				if ! $func "$reply"; then

					# If we are in silent ok, and had error, display it now
					$__AMMINPUT_BATCH_SILENTOK && ammLog::WriteTerm "${prompt}${reply}"

					ammLog::Wrn "Reply '$reply' is invalid (callback '$func')"
				else
					ammLog::Dbg "Input validated by registered '$validcb'"
					break
				fi
			else
				ammLog::Err "Validation callback '$func' is not a function. Please retry"
				unset __AMMINPUT_VALIDATIONCB[$id]
			fi

		# No validation requested
		else
			ammLog::Dbg "No validation requested."
			break
		fi

		# If failure, let the user correct its input painlessly
		default="$reply"
		ntries+=1

		sleep .1
	done

	# Register the input
	typeset file="$__AMMLIB_DATATMP/input.blueprint"
	if [[ -n "$id" ]]; then
		echo -n >>$file " --${__AMMINPUT_PREFIX}${id}='${reply}'"
	fi

	echo "$reply"
	return 0
}

# @description: 
function ammInput::SetPrefix {
	typeset pref="${1:-}"

#	if [[ -z "$pref" ]]; then
#		ammLog::Err "Prefix for input parsing cannot be empty"
#		return 1
#	fi

	__AMMINPUT_PREFIX="$pref"
}

# Populate the reply values from file, environment, options
function ammInput::Populate {
	typeset srcs="${1:-environment,options}"
	typeset prefix="${2-$__AMMINPUT_PREFIX}"

	# Loop on all registered IDs
	typeset src
	for src in ${srcs//,/ }; do
		case $src in
			# Environment vars parsing
			environment)
				# parse and protect the prefix
				typeset pfx="${prefix^^}"
				pfx="${pfx//[.-]/_}"

				# I only want env var, not shell vars, as with ( set -o posix ; set )
				typeset var val
				while IFS='=' read var val; do
					# if current environment is matching our prefix
					if [[ "$var" = $pfx* ]]; then
						typeset id="${var#$pfx}"
						id="${id%%=*}"

						# Save parsed var
						__AMMINPUT_REPLIES[$id]="$val"
						# Map input with ID for replay, option style
						__AMMINPUT_IDS[$id]="--$var"
					fi
				done < <(printenv)
				;;

			# Option parsing
			options)
				typeset -a args=()
				typeset pfx="$prefix"

				# Parse all options
				for optid in ${!__AMMLIB_CALLOPTS[@]}; do
					typeset var="${__AMMLIB_CALLOPTS[$optid]}"
					typeset orig="$var"

					# remove leading dash
					var="${var##--}"
					# if our option parsing can be done
					if [[ "$var" = $pfx* ]]; then
						# remove prefix and add reply
						typeset id="${var#$pfx}"
						id="${id%%=*}"
						typeset val="${var#*=}"
						# Save reply without prefix
						__AMMINPUT_REPLIES[$id]="$val"
						# Map input with ID for replay
						__AMMINPUT_IDS[$id]="$orig"
					else
						# Push back elemenets as they are read
						args[${#args[@]}]="$var"
					fi
				done

				# Recreate the arguments, without our options
				#set - "${args[@]}"
				__AMMLIB_CALLOPTS=("${args[@]}")
				;;

			# From /proc/cmdline
			cmdline)
				# parse all options
				for arg in $(</proc/cmdline); do
					typeset var="${arg%%=*}"
					typeset val="${arg#*=}"

					# Prefix is required for filtering
					if [[ -n $prefix ]]; then
						if [[ "$var" = $prefix* ]]; then
							var="${var#$prefix}"
						else
							# No match with prefix, skip
							continue
						fi
					fi

					__AMMINPUT_REPLIES[$var]="$val"
					__AMMINPUT_IDS[$var]="--kernel.$arg"
				done
				;;

			*)
				ammLog::Err "Unknown source type: '$src'"
				;;
		esac
	done

}

function ammInput::Blueprint {

	typeset file="$__AMMLIB_DATATMP/input.blueprint"
	[[ -s "$file" ]] || return 0

	echo
	echo "Script Blueprint: You can replay this script with your filled values with:"
	echo "$__AMMLIB_CALLNAME ${__AMMLIB_CALLOPTS[@]} $(<$file)"
}

# -----------------------------------------------------------------------------
# Validation callbacks
# -----------------------------------------------------------------------------

function ammInput::ValidateNotEmpty {
	typeset str="${1:-}"
	[[ -n "$str" ]]
}

function ammInput::ValidateInteger {
	typeset str="${1:-}"
	[[ -z "$str" ]] && return 1
	[[ -z "${str//[0-9]/}" ]]
}

function ammInput::ValidateYN {
	typeset str="${1:-}"
	ammString::IsYes "$str" || ammString::IsNo "$str"
}

function ammInput::ValidateHost {
	typeset str="${1:-}"

	[[ -z "$str" ]] && return 1
	[[ ${#str} -gt 255 ]] && return 1
	[[ "${str:-1:1}" == "." ]] && return 1

	# Validation from RFC1123
	typeset IPv4Regex="^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$"
	typeset HostRegex="^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]*[a-zA-Z0-9])\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\-]*[A-Za-z0-9])$"

	[[ $str =~ $IPv4Regex ]] || [[ $str =~ $HostRegex ]]
}


# -----------------------------------------------------------------------------
# Getters with complex types
# -----------------------------------------------------------------------------

function ammInput::GetYN {
	typeset id="$1"
	typeset prompt="$2"
	typeset default="${3:-no}"
	typeset readopts="${4:-}"

	# If a default value has been proposed, check it
	if [[ -n "$default" ]]; then
		if ammInput::ValidateYN "$default"; then
			ammLog::Dbg "Default input '$default' validated"
		else
			ammLog::Wrn "Invalid yes/no default input: '$default'"
			default=""
		fi
	fi

	typeset reply="$(ammInput::Get "$id" "$prompt [yes/no]" "$default" "$readopts" "ammInput::ValidateYN")"
	# check input
	ammString::IsYes "$reply"
	return $?
}

function ammInput::GetPassword {
	typeset id="$1"
	typeset prompt="${2:-Password (not displayed): }"
	typeset default="${3:-}"
	typeset checks="${4:-}"

	[[ -n "$default" ]] && {
		prompt+="(empty for default)"
	}

	typeset password="$(ammInput::Get "$id" "$prompt" "" "-s")"
	typeset -i ret=0

	# As the text will be silent, we need to manage default by ourself
	[[ -z "$password" ]] && [[ -n "$default" ]] && {
		password="$default"
	}

	# Recreate a line jump
	typeset _junk
	echo|read -t0 _junk >/dev/null 2>&1

	# Additionnal checks to be done
	for check in $checks; do
		typeset chkkey="${check%%:*}"
		typeset chkval="${check#*:}"

		case $chkkey in
			minsize)
				[[ ${#password} -ge $chkval ]] || {
					ammLog::Err "Password validation: Must be at least $chkval chars long (got ${#password})"
					ret+=1
				}
				;;
			maxsize)
				[[ ${#password} -le $chkval ]] || {
					ammLog::Err "Password validation: Must be at most $chkval chars long (got ${#password})"
					ret+=1
				}
				;;
			cracklib)
				if ammExec::Exists cracklib-check; then
					echo "$password" | cracklib-check >/dev/null
					ret+=$?
				else
					ammLog::Wrn "Cracklib check required, but no cracklib-check exec available. Skipping"
				fi
				;;
			*)
				ammLog::Wrn "Unknown check: $chkkey ($chkval)"
				;;
		esac
	done


	echo "$password"
	return $ret
}
