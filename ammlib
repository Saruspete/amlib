# vim: ts=4 ft=sh

# AM Modular Library
# Main file, bootstrap and load dependencies
#
# To avoid uneeded library loading, some core / often used functions are here
# (they should be in their respective library file)

set -u

export LC_ALL=C

#
# Compatibility check
#

# Check if we are using bash, else try to load the wrapper
if [[ -z "$BASH" ]] || [[ "$(cat /proc/$$/comm)" != "bash" ]]; then
	# TODO Try to find a valid wrapper
	:
fi

#

if [[ "${BASH_VERSINFO[0]:-0}" -lt 4 ]]; then
	echo >&2 "This requires bash >= 4.2 to run."
	return 1 2>/dev/null
	exit 1
fi

if [[ -n "${AMMLIB_DEBUG:-}" ]]; then
	shopt -s extdebug
fi

#
# Interactive and other calling methods specifics
#

# Check if we are started by a valid stdin
typeset    __AMMLIB_TTY="$(tty)"
typeset    __AMMLIB_INTERACTIVE=true
if [[ -z "$__AMMLIB_TTY" ]] || ! [[ -e $__AMMLIB_TTY ]]; then
	__AMMLIB_TTY=""
	__AMMLIB_INTERACTIVE=false
fi

#
# Path management
#

# @description  Path where ammlib is
typeset    __AMMLIB_REALPATH="${BASH_SOURCE[0]}"

# Check the readlink usability
if type -t readlink >/dev/null; then
	[[ "$(readlink -f "$__AMMLIB_REALPATH")" -ef "$__AMMLIB_REALPATH" ]] || {
		echo "Readlink exists ($(type "readlink")) but does not behave properly."
		echo "Please check your existing environment before retrying. Stopping here."
		echo "(press any key to exit)"
		read -s -n 1 key
		exit 1
	}
fi

# @description  How the script was called ($0)
typeset    __AMMLIB_CALLNAME="$0"
# @description  Options passed to the script ($@)
typeset -a __AMMLIB_CALLOPTS=("$@")
# @description  The file that loaded ammlib
typeset    __AMMLIB_CALLFILE="$(readlink -f ${BASH_SOURCE[1]})"
# @description  Path of the file that loaded ammlib
typeset    __AMMLIB_CALLPATH="${__AMMLIB_CALLNAME%/*}"


typeset __AMMLIB_USERNAME="$(\id -nu)"
typeset __AMMLIB_USERID="$(\id -u)"

#
# Set and create base folders to be used by library
#

# Library scripts base path
typeset __AMMLIB_ROOT="${__AMMLIB_REALPATH%/*}"

# Temporary data
typeset __AMMLIB_DATATMP="/tmp/.ammlib.${UID:-$(id -u)}/${__AMMLIB_CALLNAME##*/}.$$"
[[ -d "$__AMMLIB_DATATMP" ]] || mkdir -p "$__AMMLIB_DATATMP"

# Persistant data
typeset __AMMLIB_DATA="$HOME/.ammlib/data/"
[[ -d "$__AMMLIB_DATA" ]] || mkdir -p "$__AMMLIB_DATA"


# -----------------------------------------------------------------------------
# Exit code and trap management
# -----------------------------------------------------------------------------
typeset -A __AMMLIB_SIGNALS
typeset -A __AMMLIB_TRAP_CALLBACKS
typeset -A __AMMLIB_TRAP_REGISTERED
typeset -i __AMMLIB_TRAP_WAITMAX=30
typeset    __AMMLIB_TRAP_WAITSTEP=1

# @description:  Initialize and registers the signal handling trap
# @arg $@  Signals to be traped
function _ammLib::TrapInit {

	# Populate avaialble signals array from "trap -l" output
	if (set +u; [[ ${#__AMMLIB_SIGNALS[@]} -eq 0 ]]); then
		typeset s signum
		for s in "0)" "SIGEXIT" $(trap -l); do
			[[ "${s%)}" != "$s" ]] && signum="${s%)}"
			if [[ "${s#SIG}" != "$s" ]]; then
				__AMMLIB_SIGNALS[$signum]="${s#SIG}"
				__AMMLIB_SIGNALS[${s#SIG}]="$signum"
			fi
		done
	fi

	# Register trap with the signals as argument
	for s in "$@"; do
		trap "_ammLib::TrapHandler $s" "$s"
		__AMMLIB_TRAP_REGISTERED[$s]="ok"
	done
}

# @description:  Registers a callback
# @arg $1  The callback to call upon trap
# @arg $@  The signals to register on. Can be alises: EXITALL or EXITERR
function ammLib::TrapRegister {
	typeset callback="$1"; shift

	typeset signame
	for signame in "$@"; do
		case $signame in
			# Special alises
			EXITALL) ammLib::TrapRegister "$callback" EXIT HUP INT TERM QUIT ILL ABRT ;;
			EXITERR) ammLib::TrapRegister "$callback"      HUP INT TERM QUIT ILL ABRT ;;
			# Check for signal validity
			*)
				if (set -u; [[ -n "${__AMMLIB_SIGNALS[$signame]}" ]] ); then
					__AMMLIB_TRAP_CALLBACKS[$signame]+="$callback "
					if ! ( set +u; [[ -n "${__AMMLIB_TRAP_REGISTERED[$signame]}" ]] ); then
						ammLog::Dbg "Registered callback with uninit signal. Registering signal:$signame for callback:$callback"
						_ammLib::TrapInit "$signame"
					fi
				else
					ammLog::Wrn "Invalid signal to register callback: signal:$signame callback:$callback"
				fi
				;;
		esac
	done

}

function ammLib::TrapClean {
	# clean global temp vars
	if [[ -n ${AMMLIB_DEBUG:-} ]]; then
		ammLog::Inf "Debug enabled: Keeping temporary path '$__AMMLIB_DATATMP'"
	else
		[[ -d "$__AMMLIB_DATATMP" ]] && rm -fr "$__AMMLIB_DATATMP"
	fi
}

# Can't catch KILL CONT STOP
_ammLib::TrapInit EXIT HUP INT TERM QUIT ILL ABRT TSTP USR1 USR2
ammLib::TrapRegister "ammLib::TrapClean" EXITALL

# EXIT: Pseudo signal, standard exit of bash
# INT : Interrupt, Ctrl + C
# TERM: Default kill signal, graceful shutdown
# QUIT: Key "QUIT" (or Ctrl \) not on all keyboards
# ABRT: Call of abort(), usually by libc for ptmalloc errors
# TSTP: Stopped (Ctrl + Z)

# @description  (private) TRAP handler to clean
# @arg $1  Name of the signal
function _ammLib::TrapHandler {
	typeset retcode=$?
	typeset signame="$1"
	typeset sigtype=""

	ammLog::Dbg "Caught signal $signame with retcode $retcode"
	case $signame in
		# Standard shutdown
		EXIT)
			sigtype="EXITOK"

			# Wait for unfinished jobs
			if [[ -n "$(jobs)" ]] && [[ $__AMMLIB_TRAP_WAITMAX -gt 0 ]]; then
				ammLog::Inf "Waiting unfinished jobs in background for $__AMMLIB_TRAP_WAITMAX checks every $__AMMLIB_TRAP_WAITSTEP sec"
				typeset num pid state cmd
				typeset -i waitjob=0
				while [[ $waitjob -lt $__AMMLIB_TRAP_WAITUPTO ]]; do
					ammLog::Inf "== Check $waitjob $(ammLog::Time)"
					while read num pid state cmd; do
						ammLog::Inf "PID:$pid State:$state Command:$cmd"
					done < <(jobs -l)
					waitjob+=1
					sleep $__AMMLIB_TRAP_WAITSTEP
				done

				if [[ $waitjob -eq $__AMMLIB_TRAP_WAITUPTO ]]; then
					ammLog::Wrn "Hit timeout before all background jobs finished. Remains:"
					jobs -l | ammLog::Wrn -
				fi
			fi
			;;

		# Manual stop
		INT|HUP|TERM|QUIT)
			sigtype="EXITERR"
			ammLogWrn "Caught graceful interruption $signame. Cleaning"
			;;

		# Unamanged return code
		'')
			ammLog::Wrn "Called with empty signal name..."
			;;

		*)
			;;
	esac

	# Execute Callbacks for signame
	if ( set +u; [[ -n "${__AMMLIB_TRAP_CALLBACKS[$signame]}" ]] ); then
		typeset callback
		for callback in ${__AMMLIB_TRAP_CALLBACKS[$signame]}; do
			ammLog::Dbg "Calling callback $callback"
			$callback "$signame"
			ammLog::Dbg "Callback done. Retcode: $?"
		done
	fi

}


# -----------------------------------------------------------------------------
# Module loading
# -----------------------------------------------------------------------------
typeset __AMMLIB_SEARCHPATH="${__AMMLIB_ROOT}/lib"
typeset __AMMLIB_LOADED="ammlib lib"

# @description  Locate the library file matching given name
# @arg $1  (string) Name of the library to be loaded (eg, process)
# @stdout  (path) Path of the first matching file (in $__AMMLIB_SEARCHPATH)
function ammLib::Locate {
	typeset libname="$1"

	typeset libpath
	for libpath in $__AMMLIB_SEARCHPATH; do
			typeset nlib="${libpath}/${libname}.lib"
			[[ -r "$nlib" ]] && {
				echo "$nlib"
				return
			}
	done
}

# @description  Locate all libraries that starts with the given pattern
# @arg $1  The pattern to search against
# @stdout  (path) the list of libraries that matches the given pattern
function ammLib::LocatePattern {
	typeset libpattern="$1"

	typeset libpath lib
	for libpath in $__AMMLIB_SEARCHPATH; do
		for lib in $libpath/$libpattern*.lib; do
			echo "$lib"
		done
	done
}

# @descripton  return the library name of a given file
# @arg $1  (path) The file path to get the name from
# @stdout  (string) name of the library
function ammLib::NameFromPath {
	typeset path="$1"

	path="${path##*/}"
	path="${path%.lib}"

	echo "$path"
}

# @description  List all symbols and functions for packing
# @arg $@  (path[]) List of files to extract symbols from
function ammLib::GetSymbols {
	for file in "$@"; do
		grep -Po '^[\s]*(function[\s]+[^\s]+|[^\s]+\(\))[\s]*{' $file | awk '
			/function[ ]+([^ ]+)/ {print $2}
			/[^ ]+[ ]*()/ { gsub(/[()]/,"",$1); print $1 }'
		grep -Po '^[\s]*(typeset|declare|readonly)([\s]+-[a-zA-Z]+)?[\s]+__[^\s]+=' "$file" | awk '
			{gsub(/=$/,"",$NF); print $NF; }'
	done
}

# @description  Check if the given libname is a sub-library
# @exitcode  0 on success
function ammLib::IsSublib {
	typeset libname="$1"
	[[ "${libname//./}" != "$libname" ]]
}

# @description  Get the function name for the library' constructor
# @arg $1  (string) library name
function ammLib::MetaInitGetName {
	typeset libname="$1"

	# Input name is lowercase. Up only first char: main => Main
	typeset funcpref="${libname^}"

	# If it's a sub-library, prefix is MainSub
	if ammLib::IsSublib "$libname"; then
		# Reset the prefix
		funcpref=""
		for f in ${libname//./ }; do
			funcpref+=${f^}
		done
	fi

	echo "amm${funcpref}::MetaInit"
}


# @description  Test if a library is loadable (it's requirements are met)
# @arg $@  (string[]) Name of the library
# @exitcode 0  If all modules are loadable
# @exitcode 1+ if one or more module cannot be loaded
function ammLib::Loadable {

	typeset -i r=0

	for libname in "$@"; do
		typeset libfile="$libname"

		# If the given path was a file, find its libname from path
		if [[ -e "$libfile" ]]; then
			libname="$(ammLib::NameFromPath $libfile)"
			#libname="${libfile##*/}"
			#libname="${libname%.lib}"
		# Else, find our file
		else
			libfile="$(ammLib::Locate "$libname")"
		fi

		# If the lib exists, load it
		if [[ -n "$libfile" ]] && [[ -s "$libfile" ]]; then

			# try to load it in a subshell to check init
			typeset initfunc="$(ammLib::MetaInitGetName "$libname")"
			typeset inittext=""


			# Display the lib file
			echo "$libfile"

			# check for features starting from bash 4.2 (typeset -g)
			if [[ "${BASH_VERSINFO[0]:-0}" -eq "4" ]] && [[ "${BASH_VERSINFO[1]:-0}" -lt 2 ]]; then
				if grep -P '(typeset|declare) -[a-zA-Z]*g[a-zA-Z]* ' $libfile >/dev/null 2>&1; then
					ammLog::Dbg "Library '$libfile' needs bash >= 4.2"
					r+=1
					continue
				fi
			fi

			# Code 98 = fail during the load (parsing error ?)
			inittext="$(ammLog::Silence onlyerr; . $libfile || exit 98; if \type $initfunc >/dev/null 2>&1; then $initfunc; exit $?; else exit 0; fi;)"

			# Dont stop loading, just log error and increase return
			if [[ $? -ne 0 ]]; then
				ammLog::Dbg "Unable to load lib '$libname' (file '$libfile'). Init check failed: '$inittext'"
				r=r+1
				continue
			fi

		# Unable to load the lib
		else
			ammLog::Dbg "Unable to locate library '$libname'"
			r+=1
		fi
	done

	return $r
}

# @description  Load a library
# @arg $@  (string[]) Library name to be loaded
# @exitcode 0 if all modules were loaded successfully
# @exitcode 1+ if one or more module failed to load
function ammLib::Load {
	typeset -i r=0

	typeset libfile="" libname= l=
	for libname in "$@"; do

		libname="${libname//\"/}"
		libname="${libname//\'/}"

		# For submodule, you need to load parent module first
		if ammLib::IsSublib "$libname"; then

			# If the name is indeed a submodule, stop here
			typeset parentlib="${libname%.*}"
			typeset parentlibpath="$(ammLib::Locate "$parentlib")"
			if [[ -n "$parentlibpath" ]]; then

				typeset parentloaded=
				for l in $__AMMLIB_LOADED; do
					[[ "$l" == "$parentlib" ]] && parentloaded="$l"
				done

				if [[ -z "$parentloaded" ]]; then
					ammLog::Err "Cannot load '$libname' with ammLib::Load: look like a sub-lib of '$parentlib' and its parent '$parentlib' is not loaded"
					r=r+1
					continue
				fi
			fi
		fi

		# Skip already loaded libraries
		for l in $__AMMLIB_LOADED; do
			# Already loaded
			[[ "$libname" == "$l" ]] && continue 2
		done

		# Check if we can load requested lib
		libfile="$(ammLib::Loadable "$libname")"
		typeset libavailable=$?

		if [[ $libavailable -eq 0 ]]; then

			# Add lib early to avoid within-module reloading
			__AMMLIB_LOADED+=" $libname"

			# Init was ok, source and use lib
			. $libfile

			# Call init
			typeset metainit="$(ammLib::MetaInitGetName $libname)"
			amm::IsFunc $metainit && $metainit

			continue

		else
			if [[ -n "$libfile" ]] && [[ -s "$libfile" ]]; then
				ammLog::Err "Unable to load lib '$libname' due to failed init (enable debug with AMMLIB_DEBUG=1 for more detail)"
			else
				ammLog::Err "Unable to locate library '$libname' in search path '$__AMMLIB_SEARCHPATH'"
			fi

			r=r+1
		fi
	done

	return $r
}

# @description  Unload a module from the current session
# @arg $@   (string[]) List of modules to unload
function ammLib::Unload {
	typeset -i r=0

	# Find 
	typeset libname
	for libname in "$@"; do
		typeset libfile l
		# Check if lib was loaded
		for l in $__AMMLIB_LOADED; do
			# Not loaded
			[[ "$libname" == "$l" ]] && {
				libfile="$(ammLib::Locate "$libname")"
				continue
			}
		done

		# Skip non-loaded / non-found libraries
		[[ -z "$libfile" ]] && continue

		# Remove symbols (functions)
		typeset sym
		for sym in $(ammLib::GetSymbols "$libfile"); do
			unset $sym
		done

	done
}

# @description  Similar to ammLibLoad but exit if a module cannot be loaded
# @arg $@  (string[]) List of modules to be loaded
function ammLib::Require {
	for libname in "$@"; do

		# Spawn it in a subshell to accomodate all potential exec / checks
		ammLog::Dbg "Trying to load required lib '$libname'"
		if ! ammLib::Load "$libname"; then
			ammLog::Err "Unable to load required library '$libname'. Exiting"
			exit 1
		fi
	done

	return 0
}

# Compact all libraries to a single file, to be embedded in scripts
function ammLib::Compact {
	:
}

# @description List modules currently available
# @noargs
function ammLib::ListModules {

	typeset libpath lib
	for libpath in $(ammLib::LocatePattern); do
		[[ -s "$libpath" ]] || continue
		typeset lib=${libpath##*/}
		lib=${lib%.lib}

		echo
		echo "====== $lib ($libpath)"
	done
}

function ammLib::ListFunctions {
	typeset filename="${1:-}"

	typeset file
	for file in $(ammLib::LocatePattern $filename); do
		ammLib::GetSymbols "$file"
	done
}

# -----------------------------------------------------------------------------
# Logging
# -----------------------------------------------------------------------------

function _ammLog::ColorJoin {
	typeset IFS="$1"; shift
	echo "$*"
}

typeset -A __AMMLOG_TERMCODES=(
	# Set
	[reset]=0 [bold]=1 [dim]=2 [underline]=4 [blink]=5 [reverse]=7 [hidden]=8
	# Reset
	[resetbold]=21 [resetdim]=22 [resetunderline]=24 [resetblink]=25 [resetreverse]=27 [resethidden]=28
	# Foreground Colors
	[black]=30 [red]=31 [green]=32 [yellow]=33 [blue]=34 [magenta]=35 [cyan]=36 [white]=37 [default]=39
	# Background Colors
	[bgblack]=40 [bgred]=41 [bggreen]=42 [bgyellow]=43 [bgblue]=44 [bgmagenta]=45 [bgcyan]=46 [bgwhite]=47 [bgdefault]=49
	# Foreground Colors Light
	[lightred]=91 [lightgreen]=92 [lightyellow]=93 [lightblue]=94 [lightmagenta]=95 [lightcyan]=96 [lightwhite]=97
	# Background Colors Light
	[bglightblack]=100 [bglightred]=101 [bglightgreen]=102 [bglightyellow]=103 [bglightblue]=104 [bglightmagenta]=105 [bglightcyan]=106 [bglightwhite]=107 [bglightdefault]=109
)

typeset -i __AMMLOG_VERBOSITY=1
typeset -i __AMMLOG_DEPTH=0

# If no debug override has been done yet
[[ -n "$PS4" ]] && [[ "$PS4" != "+" ]] && {
	PS4=' (${BASH_SOURCE##*/}::${FUNCNAME[0]:-main}::$LINENO)  '
}

# @description  Colorize the text with values in __AMMLOG_TERMCODES
# @$ color codes to be printed
function ammLog::Color {
	typeset -r esc="\033["
	typeset -a codes=()

	while [[ -n "${1-}" ]]; do
		[[ -n "${__AMMLOG_TERMCODES[$1]-}" ]] && codes[${#codes[@]}+1]="${__AMMLOG_TERMCODES[$1]}"
		shift
	done

	echo -e "${esc}$(_ammLog::ColorJoin ";" ${codes[@]})m"
}

# @description  Returns the Time for the logs
# @noargs
# @stdout  Date format HH:MM:SS
function ammLog::Time {
	date '+%H:%M:%S'
}

# @description  Returns the Date for the logs
# @noargs
# @stdout  Dat format yyyy-mm-dd
function ammLog::Date {
	date '+%y-%m-%d'
}


# Log will be out to stdout
typeset __AMMLOG_FDSTD=97
typeset __AMMLOG_FDERR=98
exec 97>&1 98>&2 # Must be plain int, not the variable
typeset __AMMLOG_FDDBG=99
typeset __AMMLOG_LOGFILE=""
typeset __AMMLOG_LOGTERM=""
typeset __AMMLOG_SILENT="0"

# @description  (private) Generic log function for logging
# @arg $1  (string) tag
# @arg $2  (string) format, passed to ammLog::Color, thus keys of $__AMMLOG_TERMCODES
# @arg $@  (string[]) Text to be logged. If only "-", read as stdin.
# @stdout  (string) Resulting log
function _ammLog::Log {
	# Remove tracing if enabled to limit spam
	typeset redbg=""
	[[ "${-//x/}" != "$-" ]] && { set +x; redbg="set -x"; }

	typeset tag="$1"; shift
	typeset fmt="$1"; shift

	typeset color="$(ammLog::Color $fmt)"
	typeset colorrst="$(ammLog::Color reset)"
	typeset date="$(ammLog::Time)"

	# Read stdin
	if [[ "$@" = "-" ]]; then
		while read line; do
			# Silent mode doesn't write any log
			if [[ "$__AMMLOG_SILENT" == "0" ]]; then
				echo >&$__AMMLOG_FDSTD -e "${color}[$date][$tag][$$] $line${colorrst}"
			# Special case: only error on stdout
			elif [[ "$__AMMLOG_SILENT" == "2" ]] && [[ "$tag" == "ERR" ]]; then
				echo "[$date][$tag][$$] $line"
			fi
		done

	# Standard args
	else
		# Silent mode doesn't display any log
		if [[ "$__AMMLOG_SILENT" == "0" ]]; then
			echo >&$__AMMLOG_FDSTD -e "${color}[$date][$tag][$$] $@${colorrst}"
		elif [[ "$__AMMLOG_SILENT" == "2" ]] && [[ "$tag" == "ERR" ]]; then
			echo "[$date][$tag][$$] $@"
		fi
	fi

	# Restart tracing if was enabled
	$redbg
}


function _ammLog::Write {
	typeset tar="$1"; shift
	typeset fmt="$2"; shift
	typeset color=""
}

# @description  Log a fatal error and terminate script
# @arg $@  Log text for fatal error. If "-", text is read from stdin
function ammLog::Die {
	_ammLog::Log "ERR" "bold red" "$@"
	exit 255
}

# @description  Log an error
# @arg $@  Error text to log. If "-", text is read from stdin
function ammLog::Err {
	# TODO: add calling path
	_ammLog::Log "ERR" "bold red" "$@"
}

# @description  Log a warning
# @arg $@  warning text to log. If "-", text is read from stdin
function ammLog::Wrn {
	_ammLog::Log "WRN" "bold yellow" "$@"
}

# @description  Log an information
# @arg $@  Info text to log. If "-", text is read from stdin
function ammLog::Inf {
	_ammLog::Log "INF" "bold green" "$@"
}

# @description  Log a debug info
# @arg $@  Debug text to log. If "-", text is read from stdin
function ammLog::Dbg {

	# Remove tracing if enabled to limit spam
	typeset redbg=""
	[[ "${-//x/}" != "$-" ]] && { set +x; redbg="set -x"; }

	# Only send to log on verbose level
	if [[ -n "${AMMLIB_DEBUG:-}" ]] || [[ $__AMMLOG_VERBOSITY -ge 2 ]]; then
		# Get the caller
		typeset callerdbg="${BASH_SOURCE[1]##*/}::${FUNCNAME[1]}::${BASH_LINENO[1]}"

		_ammLog::Log "DBG" "bold blue" "[$callerdbg] $@"

	# Else, we must consume stdin or bash will fail (and add to stack nonetheless)
	else
		if [[ "$1" == "-" ]]; then
			while read line; do
				: # echo "$line" >> "${__AMMLOG_DBGFILE}.${_AMMLOG_DEPTH}"
			done
		else
			: # echo "$@" >> "${__AMMLOG_DBGFILE}.${_AMMLOG_DEPTH}"
		fi
	fi

	# Restart tracing if was enabled
	$redbg
}


# @description:  Display the stackdump of current script
# @arg $1  (int) Stack levels to skip. Default 1 (= skip this function)
# @arg $2  (int) Max levels to return. Default 255
function ammLog::Stackdump {
	typeset -i skip=${1:-1}
	typeset -i max=${2:-255}

	# Required for BASH_ARGV
	typeset    extdbg="$(shopt extdebug)"
	extdbg="${extdbg##*$'\t'}"

	typeset -i i j argoff=0
	for i in ${!BASH_SOURCE[@]}; do
		if [[ $i -lt $skip ]]; then
			argoff+=${BASH_ARGC[$i]:-0}
			continue
		fi
		[[ $i -gt $max ]] && break

		echo -n "${BASH_SOURCE[$i]##*/}::${FUNCNAME[$i]}::${BASH_LINENO[$i]} "
		if [[ "$extdbg" == "on" ]]; then
			j=$(($argoff + ${BASH_ARGC[$i]} -1))
			while [[ $j -ge $argoff ]]; do
				#echo "j=$j argoff=$argoff ARGV=${BASH_ARGV[@]}"
				echo -n "'${BASH_ARGV[$j]}' "
				j+=-1
			done
		fi
		echo
		argoff+=${BASH_ARGC[$i]:-0}
	done
}

# @description  Log for a missing binary, and try to find the packages providing them
# @arg $@  List of missing binaries to search for
function ammLog::MissingBin {

	# Load the package modules
	if ! ammLib::Loadable pkg; then
		ammLog::Err "Cannot load pkg library. Cannot find required packages"
		return 1
	fi
	ammLib::Load pkg

	typeset binlist bin
	for binlist in "$@"; do
		for bin in $binlist; do
			ammPkg::InfoWhatProvides $bin
		done
	done
}

# @description  Disable or enable logging
# @arg $1  (string) Wanted state: 0 to disable logging, "onlyerr" to only log errors, anything else to enable logging
function ammLog::Silence {
	typeset enabled="$1"

	if [[ "$enabled" == "0" ]]; then
		__AMMLOG_SILENT=0
	elif [[ "$enabled" == "onlyerr" ]]; then
		__AMMLOG_SILENT=2
	else
		__AMMLOG_SILENT=1
	fi
}

# Log xtrace (run in another process, and shares FD)
function ammLog::DebugStore {
	# Check if 
	typeset undbg=""
	[[ "${-//x/}" == "$-" ]] && { undbg="set +x"; }
	set -x
	ammLog::Dbg -
	$undbg
}

function ammLog::DebugEnable {
	exec $__AMMLOG_FDDBG> >(ammLog::DebugStore)
	BASH_XTRACEFD=$__AMMLOG_FDDBG
}

# @description  Log a message to the terminal (not through stdout). Only if session is interactive
# @arg $1  (string) message to be written
function ammLog::WriteTerm {
	typeset msg="$1"

	$__AMMLIB_INTERACTIVE || return 0

	echo > $__AMMLIB_TTY "$msg"
}

# -----------------------------------------------------------------------------
# Environment helpers
# -----------------------------------------------------------------------------

function _ammEnv::Add {
	typeset var="$1"; shift
	typeset where="${1:-after}"
	if [[ "${1:-}" == "before" ]] || [[ "${1:-}" == "after" ]]; then
		where="$1"
		shift
	fi

	typeset p
	for p in "$@"; do
		if [[ -d "$p" ]]; then
			if [[ "$where" == "before" ]]; then
				eval export $var="$p:\$$var"
			else
				eval export $var="\$$var:$p"
			fi
		fi
	done
}

# @description  Add a path to PATH
# @arg $1  (string)(optionnal). Can be "before" or "after" (default)
# @arg $@  (path[]) List of paths to be added to the env var
function ammEnv::PathAdd {
	_ammEnv::Add "PATH" "$@"
}

# @description  Add a path to LD_LIBRARY_PATH
# @arg $1  (string)(optionnal). Can be "before" or "after" (default)
# @arg $@  (path[]) List of paths to be added to the env var
function ammEnv::LibAdd {
	_ammEnv::Add "LD_LIBRARY_PATH" "$@"
}

# @description  Add a path to MANPATH
# @arg $1  (string)(optionnal). Can be "before" or "after" (default)
# @arg $@  (path[]) List of paths to be added to the env var
function ammEnv::ManAdd {
	_ammEnv::Add "MANPATH" "$@"
}

# -----------------------------------------------------------------------------
# Execution helpers
# -----------------------------------------------------------------------------

function ammExec::Logged {
	# TODO: Log the exec, return code and output of the command
	set -x
	"$@"
}

# @description  Execute a command as a different user
# @arg $1  (string) User to run the command as
# @arg $@  (string) the command to run, and its arguments. if "-", command is read from stdin
function ammExec::AsUser {
	typeset userrunas="${1:-$__AMMLIB_USERNAME}"; shift

	typeset usercurrent="$__AMMLIB_USERNAME"
	typeset -i ret=0
	typeset stmp

	# Exec from stdin
	if [[ "$@" == "-" ]]; then

		# If no user specified, or we already are correct one...
		if [[ -z "$userrunas" ]] || [[ "$userrunas" == "$usercurrent" ]]; then
			eval "$(cat)" 98>&- 99>&-
			ret=$?

		# root... yay !
		elif [[ "$usercurrent" == "root" ]]; then
			# runuser is like su, but without PAM. Preferred when exec from root
			cat | runuser -m "$userrunas" 98>&- 99>&-
			ret=$?

		else
			ammLog::Err "Cannot change from user $usercurrent to user $userrunas"
			ret=4
		fi

	# Exec from args
	else
		# No user specified, or already correct user
		if [[ -z "$userrunas" ]] || [[ "$userrunas" == "$usercurrent" ]]; then
			ammLog::Dbg "Using eval to run as '$userrunas' cmd: '$@'"
			eval "$@" 98>&- 99>&-
			ret=$?

		# root... yay !
		elif [[ "$usercurrent" == "root" ]]; then
			ammLog::Dbg "Using su to run as '$userrunas' cmd: '$*'"
			# I need to flatten
			# runuser is like su, but without PAM. Preferred when exec from root
			runuser -m -c "$*" "$userrunas" 98>&- 99>&-
			ret=$?

		# Maybe handle sudo ?
		elif stmp="$(sudo -nl 2>/dev/null|awk 'p==1; /may run the following commands/{p=1;}')" && [[ -n "$stmp" ]]; then
			ammLog::Dbg "Using sudo to run as '$userrunas' cmd: '$@'"
			# TODO: parse $stmp output more...
			sudo -n -u "$userrunas" "$@" 98>&- 99>&-
			ret=$?

			# Fails...
		else
			ammLog::Err "Cannot exec '$@' as user $userrunas from user $usercurrent"
			ret=4
		fi

	fi

}

# @description  Check if one or more command are available in PATH
# @arg $@  (string) the executables to search for
# @exitcode 0 if all are found
# @exitcode 1 if at least one is not found
function ammExec::Exists {

	typeset bin
	for bin in "$@"; do
		typeset binfound="" p
		for p in ${PATH//:/ }; do
			[[ -x "$p/$bin" ]] && {
				binfound="$p/$bin"
				break
			}
		done

		# If binary was not found in $PATH, stop here
		[[ -z "$binfound" ]] && return 1
	done
	return 0
}

# @description  Check if at least one given command is available in PATH
# @arg $@  (string) the executables to search for
# @exitcode 0 if at least one is found
# @exitcode 1 if none are found
function ammExec::RequestOne {
	typeset r=1
	typeset bin
	for bin in "$@"; do
		ammLog::Dbg "Trying to find requested bin '$bin'"
		ammExec::Exists "$bin" && return 0
	done

	ammLog::Dbg "Unable to find any of requested binaries '$@' in $PATH"
	return 1
}


# @description  Same as ammExecExists but calls ammLog::Die and terminate the script if any requested binary is not found
# @arg $@  (string) Binaries to search for in PATH
function ammExec::Requires {
	typeset bin
	for bin in "$@"; do
		ammLog::Dbg "Trying to find required bin '$bin'"
		if ! ammExec::Exists "$bin"; then
			ammLog::MissingBin "$bin"
			ammLog::Die "Unable to find required binary $bin in $PATH"
		fi
	done
	return 0
}

# @description  Same as ammExecRequestOne but calls ammLog::Die and terminates if none of requested binary is found
function ammExec::RequiresOne {
	if ! ammExec::RequestOne "$@"; then
		ammLog::MissingBin "$@"
		ammLog::Die "Unable to find any of required binaries '$@' in $PATH"
	fi
	return 0
}

# -----------------------------------------------------------------------------
# Internal script state (bash) helpers
# -----------------------------------------------------------------------------

# @description  Check if given name is a function
# @exitcode 0  is a function
# @exitcode 1  is not a function
function amm::IsFunc {
	[[ "$(type -t "$1")" == "function" ]]
}

function amm::IsAlias {
	[[ "$(type -t "$1")" == "alias" ]]
}

# @description  Check if name if a variable
# @exitcode 0  is a defined variable
# @exitcode 1  is not a variable
function amm::IsVar {
	typeset varname="$1"

	typeset var
	while read var; do
		[[ "$varname" == "${var%%=*}" ]] && return 0
	done < <(set -o posix; set)
	return 1
}
